# –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç—ã

> **‚ö†Ô∏è TODO:** –ü–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –¥–ª—è –≤—ã–Ω–æ—Å–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç—ã –∏–∑ entity –∫–ª–∞—Å—Å–∞ –≤ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —É—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–µ –∫–ª–∞—Å—Å—ã.

## üìã –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –ø—Ä–æ–±–ª–µ–º—ã

### –ê–Ω–∞–ª–∏–∑ Map Entity
- **–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞:** ~760 —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞
- **–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–æ–¥–æ–≤:** 20+ –º–µ—Ç–æ–¥–æ–≤ (–∏–∑ –Ω–∏—Ö 15+ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)
- **–°–º–µ—à–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏:** Domain entity + –∞–ª–≥–æ—Ä–∏—Ç–º—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
- **–°–ª–æ–∂–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:** –í—Å–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ entity

### –í—ã—è–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã
1. **–ù–∞—Ä—É—à–µ–Ω–∏–µ Single Responsibility Principle:** Map entity –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ò –∑–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
2. **–ù–∏–∑–∫–∞—è —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å:** –°–ª–æ–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
3. **–ù–µ—Ç –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:** –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –∫–ª–∞—Å—Å—É
4. **–°–ª–æ–∂–Ω–æ—Å—Ç—å —á—Ç–µ–Ω–∏—è:** –ë–æ–ª—å—à–æ–π —Ñ–∞–π–ª —Å —Ä–∞–∑–Ω–æ—Ä–æ–¥–Ω–æ–π –ª–æ–≥–∏–∫–æ–π
5. **–°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:** –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–º–µ—à–∞–Ω—ã —Å business logic

---

## üéØ –¶–µ–ª–µ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

### –ü—Ä–∏–Ω—Ü–∏–ø—ã —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
- **–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏:** Entity —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–∞–Ω–Ω—ã—Ö, —É—Ç–∏–ª–∏—Ç—ã –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
- **Composability:** –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- **Testability:** –ö–∞–∂–¥—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ª–µ–≥–∫–æ –ø–æ–∫—Ä—ã—Ç—å unit-—Ç–µ—Å—Ç–∞–º–∏
- **Reusability:** –ê–ª–≥–æ—Ä–∏—Ç–º—ã –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞—Ö

## üìÖ –ü–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞

### **Phase 1: –°–æ–∑–¥–∞–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏ –±–∞–∑–æ–≤—ã—Ö —É—Ç–∏–ª–∏—Ç** ‚è±Ô∏è 1-2 –Ω–µ–¥–µ–ª–∏

#### 1.1 –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–∫–µ—Ç–∞ map-generation
```bash
# TODO: –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø–∞–∫–µ—Ç –≤ libs/
mkdir -p libs/map-generation/src/{terrain,resources,spawn,validation,utils,types}
```

#### 1.2 –ë–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ã –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
```typescript
// TODO: libs/map-generation/src/types/GenerationConfig.ts
export interface TerrainGenerationConfig {
  size: { x: number; y: number };
  layers: {
    dirt: { baseChance: number };
    rock: { distanceMultiplier: number };
    bedrock: { centralBonus: number };
  };
  formations: {
    bedrockFormations: { density: number; radius: Range };
    rockVeins: { density: number; length: Range };
  };
}

export interface ResourceGenerationConfig {
  playersCount: number;
  baseDensity: number;
  playerMultiplier: number;
  zones: {
    central: { radius: number };
    middle: { radius: number };
  };
  clustering: {
    gold: { radius: Range; density: number };
    iron: { radius: Range; density: number };
    crystal: { radius: Range; density: number };
  };
  spacing: {
    sameType: number;
    differentTypes: number;
    fromSpawn: number;
  };
}

export interface SpawnGenerationConfig {
  playersCount: number;
  margin: number;
  minDistance: number;
  accessibility: {
    immediateRadius: number;
    clearRadius: number;
  };
  guaranteedResources: {
    enabled: boolean;
    minDistance: number;
    maxDistance: number;
  };
}

type Range = { min: number; max: number };
```

#### 1.3 –ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ —É—Ç–∏–ª–∏—Ç—ã
```typescript
// TODO: libs/map-generation/src/utils/GeometryUtils.ts
export class GeometryUtils {
  static distance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }

  static isWithinBounds(x: number, y: number, bounds: { width: number; height: number }): boolean {
    return x >= 0 && x < bounds.width && y >= 0 && y < bounds.height;
  }

  static getNeighbors8(x: number, y: number): Array<{ x: number; y: number }> {
    return [
      { x: x - 1, y: y - 1 }, { x: x, y: y - 1 }, { x: x + 1, y: y - 1 },
      { x: x - 1, y: y },                         { x: x + 1, y: y },
      { x: x - 1, y: y + 1 }, { x: x, y: y + 1 }, { x: x + 1, y: y + 1 }
    ];
  }

  static getNeighbors4(x: number, y: number): Array<{ x: number; y: number }> {
    return [
      { x: x, y: y - 1 },
      { x: x - 1, y: y }, { x: x + 1, y: y },
      { x: x, y: y + 1 }
    ];
  }

  static polarToCartesian(centerX: number, centerY: number, radius: number, angle: number): { x: number; y: number } {
    return {
      x: Math.floor(centerX + Math.cos(angle) * radius),
      y: Math.floor(centerY + Math.sin(angle) * radius)
    };
  }
}
```

### **Phase 2: –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã —Ç–µ—Ä—Ä–µ–π–Ω–∞** ‚è±Ô∏è 2-3 –Ω–µ–¥–µ–ª–∏

#### 2.1 TerrainLayerGenerator
```typescript
// TODO: libs/map-generation/src/terrain/TerrainLayerGenerator.ts
export class TerrainLayerGenerator {
  constructor(private config: TerrainGenerationConfig) {}

  generateBaseLayers(terrainData: TerrainType[][]): void {
    const { size } = this.config;
    const centerX = Math.floor(size.x / 2);
    const centerY = Math.floor(size.y / 2);
    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);

    for (let y = 0; y < size.y; y++) {
      for (let x = 0; x < size.x; x++) {
        const distanceFromCenter = GeometryUtils.distance(x, y, centerX, centerY);
        const normalizedDistance = distanceFromCenter / maxDistance;

        const terrain = this.calculateTerrainType(normalizedDistance);
        terrainData[y][x] = terrain;
      }
    }
  }

  private calculateTerrainType(normalizedDistance: number): TerrainType {
    const { layers } = this.config;
    const random = Math.random();

    const rockProbability = normalizedDistance * layers.rock.distanceMultiplier;
    const bedrockProbability = (1 - normalizedDistance) * layers.bedrock.centralBonus;

    if (random < bedrockProbability) {
      return TerrainType.Bedrock;
    } else if (random < bedrockProbability + rockProbability) {
      return TerrainType.Rock;
    }

    return TerrainType.Dirt;
  }
}
```

#### 2.2 BedrockFormationGenerator
```typescript
// TODO: libs/map-generation/src/terrain/BedrockFormationGenerator.ts
export class BedrockFormationGenerator {
  constructor(private config: TerrainGenerationConfig) {}

  generateFormations(terrainData: TerrainType[][]): void {
    const { size, formations } = this.config;
    const formationCount = Math.floor((size.x * size.y) / formations.bedrockFormations.density);

    for (let i = 0; i < formationCount; i++) {
      this.generateSingleFormation(terrainData);
    }
  }

  private generateSingleFormation(terrainData: TerrainType[][]): void {
    const { size, formations } = this.config;
    const centerX = Math.floor(Math.random() * size.x);
    const centerY = Math.floor(Math.random() * size.y);
    const radius = NoiseGenerator.randomInRange(formations.bedrockFormations.radius);

    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const x = centerX + dx;
        const y = centerY + dy;

        if (GeometryUtils.isWithinBounds(x, y, size)) {
          const distance = GeometryUtils.distance(0, 0, dx, dy);
          const probability = Math.max(0, 1 - distance / radius);

          if (Math.random() < probability * 0.8) {
            terrainData[y][x] = TerrainType.Bedrock;
          }
        }
      }
    }
  }
}
```

### **Phase 3: –°–∏—Å—Ç–µ–º–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤** ‚è±Ô∏è 3-4 –Ω–µ–¥–µ–ª–∏

#### 3.1 ResourcePlacementEngine
```typescript
// TODO: libs/map-generation/src/resources/ResourcePlacementEngine.ts
export class ResourcePlacementEngine {
  private strategy: ResourcePlacementStrategy;
  private clusterGenerator: ContiguousClusterGenerator;
  private balancer: ResourceBalancer;

  constructor(
    private config: ResourceGenerationConfig,
    strategy?: ResourcePlacementStrategy
  ) {
    this.strategy = strategy ?? new ZonedResourceStrategy(config);
    this.clusterGenerator = new ContiguousClusterGenerator();
    this.balancer = new ResourceBalancer(config);
  }

  async generateResources(
    terrainData: TerrainType[][],
    spawnPoints: Array<{ x: number; y: number }>
  ): Promise<void> {
    // –†–∞—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
    const resourceCounts = this.balancer.calculateResourceCounts();

    // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –ø–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
    const placements = await this.strategy.placeClusters(
      terrainData,
      spawnPoints,
      resourceCounts
    );

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
    for (const placement of placements) {
      await this.clusterGenerator.generateCluster(
        terrainData,
        placement.x,
        placement.y,
        placement.type,
        placement.config
      );
    }
  }
}

export interface ResourcePlacementStrategy {
  placeClusters(
    terrainData: TerrainType[][],
    spawnPoints: Array<{ x: number; y: number }>,
    resourceCounts: ResourceCounts
  ): Promise<ResourcePlacement[]>;
}
```

#### 3.2 ZonedResourceStrategy
```typescript
// TODO: libs/map-generation/src/resources/ZonedResourceStrategy.ts
export class ZonedResourceStrategy implements ResourcePlacementStrategy {
  constructor(private config: ResourceGenerationConfig) {}

  async placeClusters(
    terrainData: TerrainType[][],
    spawnPoints: Array<{ x: number; y: number }>,
    resourceCounts: ResourceCounts
  ): Promise<ResourcePlacement[]> {
    const zones = this.calculateZones(terrainData);
    const placements: ResourcePlacement[] = [];

    // –ö—Ä–∏—Å—Ç–∞–ª–ª—ã —Ç–æ–ª—å–∫–æ –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –∑–æ–Ω–µ
    placements.push(...await this.placeCrystalsInZone(zones.central, resourceCounts.crystals));

    // –ó–æ–ª–æ—Ç–æ –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –∏ —Å—Ä–µ–¥–Ω–µ–π –∑–æ–Ω–∞—Ö
    placements.push(...await this.placeGoldInZones(zones, resourceCounts.gold));

    // –ñ–µ–ª–µ–∑–æ –≤ —Å—Ä–µ–¥–Ω–µ–π –∏ –≤–Ω–µ—à–Ω–µ–π –∑–æ–Ω–∞—Ö
    placements.push(...await this.placeIronInZones(zones, resourceCounts.iron));

    return placements;
  }

  private calculateZones(terrainData: TerrainType[][]): MapZones {
    const size = { x: terrainData[0].length, y: terrainData.length };
    const centerX = Math.floor(size.x / 2);
    const centerY = Math.floor(size.y / 2);
    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);

    return {
      central: {
        centerX, centerY,
        radius: maxDistance * this.config.zones.central.radius
      },
      middle: {
        centerX, centerY,
        radius: maxDistance * this.config.zones.middle.radius
      },
      outer: {
        centerX, centerY,
        radius: maxDistance
      }
    };
  }
}
```

### **Phase 4: –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–ø–∞–≤–Ω-–ø–æ–∏–Ω—Ç–æ–≤** ‚è±Ô∏è 1-2 –Ω–µ–¥–µ–ª–∏

#### 4.1 SpawnPointGenerator
```typescript
// TODO: libs/map-generation/src/spawn/SpawnPointGenerator.ts
export class SpawnPointGenerator {
  private positionCalculator: SpawnPositionCalculator;
  private accessibilityEnsurer: SpawnAccessibilityEnsurer;

  constructor(private config: SpawnGenerationConfig) {
    this.positionCalculator = new SpawnPositionCalculator(config);
    this.accessibilityEnsurer = new SpawnAccessibilityEnsurer(config);
  }

  generateSpawnPoints(
    terrainData: TerrainType[][],
    size: { x: number; y: number }
  ): Array<{ x: number; y: number }> {
    // –†–∞—Å—á–µ—Ç –ø–æ–∑–∏—Ü–∏–π —Å–ø–∞–≤–Ω–∞
    const positions = this.positionCalculator.calculatePositions(size);

    // –û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
    this.accessibilityEnsurer.ensureAccessibility(terrainData, positions);

    // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
    if (this.config.guaranteedResources.enabled) {
      this.accessibilityEnsurer.placeGuaranteedResources(terrainData, positions);
    }

    return positions;
  }
}
```

### **Phase 5: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Map Entity** ‚è±Ô∏è 1 –Ω–µ–¥–µ–ª—è

#### 5.1 –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è Map Entity
```typescript
// TODO: –û–±–Ω–æ–≤–∏—Ç—å apps/backend/src/map/domain/map.entity.ts
export class Map {
  public readonly id: Uuid;
  public readonly size: MapSize;
  public terrainData: TerrainType[][];
  public spawnPoints: SpawnPoint[];

  // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
  constructor(params: MapConstructorParams) { /* ... */ }

  // –ú–µ—Ç–æ–¥—ã –¥–ª—è –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏ (–ù–ï –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)
  public digTerrain(x: number, y: number): boolean { /* ... */ }
  public isTerrainPassable(x: number, y: number): boolean { /* ... */ }
  public canBuildAt(x: number, y: number): boolean { /* ... */ }

  // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ —É—Ç–∏–ª–∏—Ç–∞–º)
  public generateTerrain(): void {
    const generator = new TerrainGenerator({
      size: { x: this.size.x, y: this.size.y },
      // ... –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    });

    this.terrainData = generator.generate();
  }

  public generateTerrainWithResources(playersCount: number): void {
    this.generateTerrain();
    this.generateSpawnPoints(playersCount);

    const resourceEngine = new ResourcePlacementEngine({
      playersCount,
      // ... –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    });

    resourceEngine.generateResources(
      this.terrainData,
      this.spawnPoints.map(sp => sp.toJSON())
    );
  }

  public generateSpawnPoints(playersCount: number): void {
    const generator = new SpawnPointGenerator({
      playersCount,
      // ... –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    });

    const positions = generator.generateSpawnPoints(
      this.terrainData,
      { x: this.size.x, y: this.size.y }
    );

    this.spawnPoints = positions.map(pos => new SpawnPoint(pos.x, pos.y));
  }
}
```

---

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Unit —Ç–µ—Å—Ç—ã –¥–ª—è —É—Ç–∏–ª–∏—Ç
```typescript
// TODO: libs/map-generation/src/terrain/__tests__/TerrainLayerGenerator.test.ts
describe('TerrainLayerGenerator', () => {
  it('should generate consistent terrain layers') {
    const config = createTestConfig();
    const generator = new TerrainLayerGenerator(config);
    const terrain = Array(100).fill(null).map(() => Array(100).fill(TerrainType.Dirt));

    generator.generateBaseLayers(terrain);

    expect(terrain[50][50]).toBe(TerrainType.Bedrock); // –¶–µ–Ω—Ç—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å bedrock
    expect(terrain[0][0]).not.toBe(TerrainType.Bedrock); // –£–≥–ª—ã –Ω–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å bedrock
  });

  it('should respect configuration parameters') {
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π
  });
});

describe('ResourcePlacementEngine', () => {
  it('should place resources according to strategy') {
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤
  });

  it('should maintain minimum distances between clusters') {
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±–ª—é–¥–µ–Ω–∏—è –¥–∏—Å—Ç–∞–Ω—Ü–∏–π
  });
});
```

### Integration —Ç–µ—Å—Ç—ã
```typescript
// TODO: apps/backend/src/map/__tests__/map-generation-integration.test.ts
describe('Map Generation Integration', () => {
  it('should generate valid map with all components') {
    const map = new Map({
      id: new Uuid(),
      size: new MapSize(100, 100)
    });

    map.generateTerrainWithResources(4);

    expect(map.spawnPoints).toHaveLength(4);
    expect(map.terrainData).toBeDefined();
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–∞—Ä—Ç—ã
  });
});
```

---

## üìä –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞

### –î–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞:
- **Map.entity.ts:** 760 —Å—Ç—Ä–æ–∫, 20+ –º–µ—Ç–æ–¥–æ–≤
- **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:** –°–ª–æ–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- **–ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:** –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ
- **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å:** –ù–∏–∑–∫–∞—è –∏–∑-–∑–∞ —Å–º–µ—à–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏

### –ü–æ—Å–ª–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞:
- **Map.entity.ts:** ~150 —Å—Ç—Ä–æ–∫, —Ñ–æ–∫—É—Å –Ω–∞ business logic
- **–£—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–µ –∫–ª–∞—Å—Å—ã:** 8-10 —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤
- **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:** –ö–∞–∂–¥—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–∫—Ä—ã—Ç unit-—Ç–µ—Å—Ç–∞–º–∏
- **–ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:** –ê–ª–≥–æ—Ä–∏—Ç–º—ã –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞—Ö
- **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å:** –í—ã—Å–æ–∫–∞—è –±–ª–∞–≥–æ–¥–∞—Ä—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—é –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏

### –ú–µ—Ç—Ä–∏–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞:
- **Cyclomatic Complexity:** –°–Ω–∏–∂–µ–Ω–∏–µ –≤ 3-4 —Ä–∞–∑–∞
- **Test Coverage:** –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å 30% –¥–æ 90%+
- **Lines of Code per Class:** –°–Ω–∏–∂–µ–Ω–∏–µ —Å 760 –¥–æ 50-150
- **Maintainability Index:** –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –Ω–∞ 40-50%

---

## üîó –°–≤—è–∑—å —Å –ø–ª–∞–Ω–æ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

–î–∞–Ω–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ **—Ö–æ—Ä–æ—à–æ —Å–æ—á–µ—Ç–∞–µ—Ç—Å—è** —Å [–ø–ª–∞–Ω–æ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º—ã –∫–∞—Ä—Ç](./09_map_optimization_refactoring_plan.md):

1. **–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:** –£—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–µ –∫–ª–∞—Å—Å—ã –ª–µ–≥–∫–æ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —á–∞–Ω–∫–∞–º–∏
2. **–¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å:** –ü—Ä–æ—â–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ –Ω–µ–±–æ–ª—å—à–∏—Ö —á–∞–Ω–∫–∞—Ö
3. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** –ú–æ–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –¥–ª—è chunked-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
4. **–ú–∏–≥—Ä–∞—Ü–∏—è:** –ù–æ–≤—ã–µ —É—Ç–∏–ª–∏—Ç—ã –æ–±–ª–µ–≥—á–∞—Ç –º–∏–≥—Ä–∞—Ü–∏—é —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–∞—Ä—Ç

### –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –ø–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:
1. **–°–Ω–∞—á–∞–ª–∞:** –î–∞–Ω–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ (—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤)
2. **–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ:** [–°–∏—Å—Ç–µ–º–∞ —Å–ª–æ–µ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç](./11_layered_map_generation_system.md) (–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤)
3. **–ó–∞—Ç–µ–º:** –ü–ª–∞–Ω –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (chunking + —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è)

---

## ‚úÖ –ö—Ä–∏—Ç–µ—Ä–∏–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏

- [ ] –í—Å–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –≤—ã–Ω–µ—Å–µ–Ω—ã –∏–∑ Map entity
- [ ] Map entity —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ business logic –∏ delegation
- [ ] –ö–∞–∂–¥—ã–π —É—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–π –∫–ª–∞—Å—Å –ø–æ–∫—Ä—ã—Ç unit-—Ç–µ—Å—Ç–∞–º–∏ (>90%)
- [ ] Integration —Ç–µ—Å—Ç—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
- [ ] –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ —É—Ö—É–¥—à–∏–ª–∞—Å—å
- [ ] –ö–æ–¥ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–º –ø—Ä–∏–Ω—Ü–∏–ø–∞–º –ø—Ä–æ–µ–∫—Ç–∞

---

> **‚ö†Ô∏è –í–∞–∂–Ω–æ:** –≠—Ç–æ—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ —Ä–∞–∑–≤–∏—Ç–∏—è —Å–∏—Å—Ç–µ–º—ã. –ë–µ–∑ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –±—É–¥–µ—Ç —Å–ª–æ–∂–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞–∑–≤–∏–≤–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç.

> **‚úÖ –í—ã–≥–æ–¥–∞:** –ü–æ—Å–ª–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –∫–æ–º–∞–Ω–¥–∞ —Å–º–æ–∂–µ—Ç –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏, A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤.